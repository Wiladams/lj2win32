
-- Unicode text shaping API (Uniscribe)

local ffi = require("ffi")

require ("win32.winapifamily")
require("win32.windef")


--[[
/////   USP - Unicode Complex Script processor
//
//      Copyright (c) Microsoft Corporation. All rights reserved.
--]]



ffi.cdef[[
static const int SCRIPT_UNDEFINED  = 0;
]]

--[[
/////   USP Status Codes
//
#define USP_E_SCRIPT_NOT_IN_FONT   \
        MAKE_HRESULT(SEVERITY_ERROR,FACILITY_ITF,0x200)    // Script doesn't exist in font
--]]





ffi.cdef[[
typedef void *SCRIPT_CACHE;

HRESULT  ScriptFreeCache(SCRIPT_CACHE   *psc);       //InOut  Cache handle


typedef struct tag_SCRIPT_CONTROL {
    DWORD   uDefaultLanguage    :16; // For NADS, also default for context
    DWORD   fContextDigits      :1;  // Means use previous script instead of uDefaultLanguage

    // The following flags provide legacy support for GetCharacterPlacement features
    DWORD   fInvertPreBoundDir  :1;  // Reading order of virtual item immediately prior to string
    DWORD   fInvertPostBoundDir :1;  // Reading order of virtual item immediately following string
    DWORD   fLinkStringBefore   :1;  // Equivalent to presence of ZWJ before string
    DWORD   fLinkStringAfter    :1;  // Equivalent to presence of ZWJ after string
    DWORD   fNeutralOverride    :1;  // Causes all neutrals to be strong in the current embedding direction
    DWORD   fNumericOverride    :1;  // Causes all numerals to be strong in the current embedding direction
    DWORD   fLegacyBidiClass    :1;  // Causes plus and minus to be reated as neutrals, slash as a common separator
    DWORD   fMergeNeutralItems  :1;  // Causes merging neutral characters into strong items, when possible
    DWORD   fUseStandardBidi    :1;  // Causes matching pair algorithm to be skipped
    DWORD   fReserved           :6;  
} SCRIPT_CONTROL;


typedef struct tag_SCRIPT_STATE {
    WORD    uBidiLevel         :5;  // Unicode Bidi algorithm embedding level (0-16)
    WORD    fOverrideDirection :1;  // Set when in LRO/RLO embedding
    WORD    fInhibitSymSwap    :1;  // Set by U+206A (ISS), cleared by U+206B (ASS)
    WORD    fCharShape         :1;  // Set by U+206D (AAFS), cleared by U+206C (IAFS)
    WORD    fDigitSubstitute   :1;  // Set by U+206E (NADS), cleared by U+206F (NODS)
    WORD    fInhibitLigate     :1;  // Equiv !GCP_Ligate, no Unicode control chars yet
    WORD    fDisplayZWG        :1;  // Equiv GCP_DisplayZWG, no Unicode control characters yet
    WORD    fArabicNumContext  :1;  // For EN->AN Unicode rule
    WORD    fGcpClusters       :1;  // For Generating Backward Compatible GCP Clusters (legacy Apps)
    WORD    fReserved          :1;
    WORD    fEngineReserved    :2;  // For use by shaping engine
} SCRIPT_STATE;


typedef struct tag_SCRIPT_ANALYSIS {
    WORD    eScript         :10;    // Shaping engine
    WORD    fRTL            :1;     // Rendering direction
    WORD    fLayoutRTL      :1;     // Set for GCP classes ARABIC/HEBREW and LOCALNUMBER
    WORD    fLinkBefore     :1;     // Implies there was a ZWJ before this item
    WORD    fLinkAfter      :1;     // Implies there is a ZWJ following this item.
    WORD    fLogicalOrder   :1;     // Set by client as input to ScriptShape/Place
    WORD    fNoGlyphIndex   :1;     // Generated by ScriptShape/Place - this item does not use glyph indices
    SCRIPT_STATE s;
} SCRIPT_ANALYSIS;

typedef struct tag_SCRIPT_ITEM {
    int              iCharPos;      // Logical offset to first character in this item
    SCRIPT_ANALYSIS  a;
} SCRIPT_ITEM;
]]

ffi.cdef[[
HRESULT  ScriptItemize(
    const WCHAR                   *pwcInChars,    // In   Unicode string to be itemized
    int                                                 cInChars,       // In   Codepoint count to itemize
    int                                                 cMaxItems,      // In   Max length of itemization array
    const SCRIPT_CONTROL             *psControl,     // In   Analysis control (optional)
    const SCRIPT_STATE               *psState,       // In   Initial bidi algorithm state (optional)
    SCRIPT_ITEM  *pItems,        // Out  Array to receive itemization
    int                                 *pcItems);      // Out  Count of items processed (optional)



HRESULT  ScriptLayout(
    int                             cRuns,                  // In   Number of runs to process
    const BYTE    *pbLevel,               // In   Array of run embedding levels
    int *piVisualToLogical,     // Out  List of run indices in visual order
    int *piLogicalToVisual);    // Out  List of visual run positions
]]

ffi.cdef[[
typedef enum tag_SCRIPT_JUSTIFY {
    SCRIPT_JUSTIFY_NONE           = 0,   // Justification cant be applied at this glyph
    SCRIPT_JUSTIFY_ARABIC_BLANK   = 1,   // This glyph represents a blank in an Arabic run
    SCRIPT_JUSTIFY_CHARACTER      = 2,   // Inter-character justification point follows this glyph
    SCRIPT_JUSTIFY_RESERVED1      = 3,   // Reserved #1
    SCRIPT_JUSTIFY_BLANK          = 4,   // This glyph represents a blank outside an Arabic run
    SCRIPT_JUSTIFY_RESERVED2      = 5,   // Reserved #2
    SCRIPT_JUSTIFY_RESERVED3      = 6,   // Reserved #3
    SCRIPT_JUSTIFY_ARABIC_NORMAL  = 7,   // Normal Middle-Of-Word glyph that connects to the right (begin)
    SCRIPT_JUSTIFY_ARABIC_KASHIDA = 8,   // Kashida(U+640) in middle of word
    SCRIPT_JUSTIFY_ARABIC_ALEF    = 9,   // Final form of Alef-like (U+627, U+625, U+623, U+632)
    SCRIPT_JUSTIFY_ARABIC_HA      = 10,  // Final form of Ha (U+647)
    SCRIPT_JUSTIFY_ARABIC_RA      = 11,  // Final form of Ra (U+631)
    SCRIPT_JUSTIFY_ARABIC_BA      = 12,  // Middle-Of-Word form of Ba (U+628)
    SCRIPT_JUSTIFY_ARABIC_BARA    = 13,  // Ligature of alike (U+628,U+631)
    SCRIPT_JUSTIFY_ARABIC_SEEN    = 14,  // Highest priority: Initial shape of Seen(U+633) (end)
    SCRIPT_JUSTIFY_ARABIC_SEEN_M  = 15,  // Reserved #4
} SCRIPT_JUSTIFY;


typedef struct tag_SCRIPT_VISATTR {
    WORD           uJustification   :4;  // Justification class
    WORD           fClusterStart    :1;  // First glyph of representation of cluster
    WORD           fDiacritic       :1;  // Diacritic
    WORD           fZeroWidth       :1;  // Blank, ZWJ, ZWNJ etc, with no width
    WORD           fReserved        :1;  // General reserved
    WORD           fShapeReserved   :8;  // Reserved for use by shaping engines
} SCRIPT_VISATTR;


HRESULT  ScriptShape(
    HDC                                                     hdc,            // In    Optional (see under caching)
    SCRIPT_CACHE                         *psc,           // InOut Cache handle
    const WCHAR                          *pwcChars,      // In    Logical unicode run
    int                                                     cChars,         // In    Length of unicode run
    int                                                     cMaxGlyphs,     // In    Max glyphs to generate
    SCRIPT_ANALYSIS                      *psa,           // InOut Result of ScriptItemize (may have fNoGlyphIndex set)
    WORD             *pwOutGlyphs,   // Out   Output glyph buffer
    WORD                           *pwLogClust,    // Out   Logical clusters
    SCRIPT_VISATTR   *psva,          // Out   Visual glyph attributes
    int                                     *pcGlyphs);     // Out   Count of glyphs generated
]]



if not LSDEFS_DEFINED then
ffi.cdef[[
typedef struct tagGOFFSET {
    LONG  du;
    LONG  dv;
} GOFFSET;
]]
end


ffi.cdef[[
HRESULT  ScriptPlace(
    HDC                    hdc,        
    SCRIPT_CACHE             *psc,     
    const WORD              *pwGlyphs, 
    int                    cGlyphs,
    const SCRIPT_VISATTR    *psva,
    SCRIPT_ANALYSIS          *psa,
    int               *piAdvance,
    GOFFSET       *pGoffset,
    ABC                    *pABC);
]]


ffi.cdef[[
 HRESULT  ScriptTextOut(
    const HDC                               hdc,            // In     OS handle to device context (required)
    SCRIPT_CACHE        *psc,           // InOut  Cache handle
    int                                     x,              // In     x,y position for first glyph
    int                                     y,              // In
    UINT                                    fuOptions,      // In     ExtTextOut options
     const RECT           *lprc,          // In     optional clipping/opaquing rectangle
    const SCRIPT_ANALYSIS    *psa,           // In     Result of ScriptItemize
    const WCHAR                  *pwcReserved,   // In     Reserved (requires NULL)
    int                          iReserved,      // In     Reserved (requires 0)
     const WORD         *pwGlyphs,      // In     Glyph buffer from prior ScriptShape call
    int                                     cGlyphs,        // In     Number of glyphs
     const int          *piAdvance,     // In     Advance widths from ScriptPlace
    const int      *piJustify,     // In     Justified advance widths (optional)
     const GOFFSET      *pGoffset);     // In     x,y offset for combining glyph


 HRESULT  ScriptJustify(
     const SCRIPT_VISATTR   *psva,          // In   Collected visual attributes for entire line
     const int              *piAdvance,     // In   Advance widths from ScriptPlace
    int                                         cGlyphs,        // In   Size of all arrays
    int                                         iDx,            // In   Desired width change, either increase or descrease
    int                                         iMinKashida,    // In   Minimum length of continuous kashida glyph to generate
     int              *piJustify);    // Out  Updated advance widths to pass to ScriptTextOut


typedef struct tag_SCRIPT_LOGATTR {
    BYTE    fSoftBreak      :1;     // Potential linebreak point
    BYTE    fWhiteSpace     :1;     // A unicode whitespace character, except NBSP, ZWNBSP
    BYTE    fCharStop       :1;     // Valid cursor position (for left/right arrow)
    BYTE    fWordStop       :1;     // Valid cursor position (for ctrl + left/right arrow)
    BYTE    fInvalid        :1;     // Invalid character sequence
    BYTE    fReserved       :3;
} SCRIPT_LOGATTR;


 HRESULT  ScriptBreak(
     const WCHAR             *pwcChars,  // In   Logical unicode item
    int                                         cChars,     // In   Length of unicode item
    const SCRIPT_ANALYSIS        *psa,       // In   Result of earlier ScriptItemize call
     SCRIPT_LOGATTR    *psla);     // Out  Logical character attributes



 HRESULT  ScriptCPtoX(
    int                                         iCP,            // In   Logical character position in run
    BOOL                                        fTrailing,      // In   Which edge (default - leading)
    int                                         cChars,         // In   Count of logical codepoints in run
    int                                         cGlyphs,        // In   Count of glyphs in run
     const WORD              *pwLogClust,    // In   Logical clusters
     const SCRIPT_VISATTR   *psva,          // In   Visual glyph attributes array
     const int              *piAdvance,     // In   Advance widths
    const SCRIPT_ANALYSIS        *psa,           // In   Script analysis from item attributes
    int                                         *piX);          // Out  Resulting X position



 HRESULT  ScriptXtoCP(
    int                                         iX,             // In   X offset from left of run
    int                                         cChars,         // In   Count of logical codepoints in run
    int                                         cGlyphs,        // In   Count of glyphs in run
     const WORD              *pwLogClust,    // In   Logical clusters
     const SCRIPT_VISATTR   *psva,          // In   Visual glyph attributes
     const int              *piAdvance,     // In   Advance widths
    const SCRIPT_ANALYSIS        *psa,           // In   Script analysis from item attributes
     int                         *piCP,          // Out  Resulting character position
     int                         *piTrailing);   // Out  Leading or trailing half flag


 HRESULT  ScriptGetLogicalWidths(
    const SCRIPT_ANALYSIS        *psa,           // In   Script analysis from item attributes
    int                                         cChars,         // In   Count of logical codepoints in run
    int                                         cGlyphs,        // In   Count of glyphs in run
     const int              *piGlyphWidth,  // In   Advance widths
     const WORD              *pwLogClust,    // In   Logical clusters
     const SCRIPT_VISATTR   *psva,          // In   Visual glyph attributes
     int                     *piDx);         // Out  Logical widths
]]

ffi.cdef[[
 HRESULT  ScriptApplyLogicalWidth(
     const int               *piDx,          // In     Logical dx array to apply
    int                                         cChars,         // In     Count of logical codepoints in run
    int                                         cGlyphs,        // In     Glyph count
     const WORD              *pwLogClust,    // In     Logical clusters
     const SCRIPT_VISATTR   *psva,          // In     Visual attributes from ScriptShape/Place
     const int              *piAdvance,     // In     Glyph advance widths from ScriptPlace
    const SCRIPT_ANALYSIS        *psa,           // In     Script analysis from item attributes
     ABC                   *pABC,          // InOut  Updated item ABC width (optional)
     int              *piJustify);    // Out    Resulting glyph advance widths for ScriptTextOut
]]







ffi.cdef[[
static const int SGCM_RTL  = 0x00000001;      // Return mirrored glyph for mirrorable Unicode codepoints


HRESULT  ScriptGetCMap(
    HDC                                     hdc,            // In    Optional (see notes on caching)
    SCRIPT_CACHE        *psc,           // InOut Address of Cache handle
    const WCHAR         *pwcInChars,    // In    Unicode codepoint(s) to look up
    int                                     cChars,         // In    Number of characters
    DWORD                                   dwFlags,        // In    Flags such as SGCM_RTL
    WORD               *pwOutGlyphs);  // Out   Array of glyphs, one per input character


HRESULT  ScriptGetGlyphABCWidth(
    HDC                                     hdc,        // In    Optional (see notes on caching)
    SCRIPT_CACHE        *psc,       // InOut Address of Cache handle
    WORD                                    wGlyph,     // In    Glyph
    ABC                     *pABC);     // Out   ABC width


typedef struct {
    DWORD   langid                 :16; // Primary and sublanguage associated with script
    DWORD   fNumeric               :1;
    DWORD   fComplex               :1;  // Script requires special shaping or layout
    DWORD   fNeedsWordBreaking     :1;  // Requires ScriptBreak for word breaking information
    DWORD   fNeedsCaretInfo        :1;  // Requires caret restriction to cluster boundaries
    DWORD   bCharSet               :8;  // Charset to use when creating font
    DWORD   fControl               :1;  // Contains only control characters
    DWORD   fPrivateUseArea        :1;  // This item is from the Unicode range U+E000 through U+F8FF
    DWORD   fNeedsCharacterJustify :1;  // Requires inter-character justification
    DWORD   fInvalidGlyph          :1;  // Invalid combinations generate glyph wgInvalid in the glyph buffer
    DWORD   fInvalidLogAttr        :1;  // Invalid combinations are marked by fInvalid in the logical attributes
    DWORD   fCDM                   :1;  // Contains Combining Diacritical Marks
    DWORD   fAmbiguousCharSet      :1;  // Script does not correspond 1:1 with a charset
    DWORD   fClusterSizeVaries     :1;  // Measured cluster width depends on adjacent clusters
    DWORD   fRejectInvalid         :1;  // Invalid combinations should be rejected
} SCRIPT_PROPERTIES;
]]


ffi.cdef[[
HRESULT  ScriptGetProperties(
    const SCRIPT_PROPERTIES   ***ppSp,        // Out  Receives pointer to table of pointers to properties indexed by script
    int                       *piNumScripts); // Out  Receives number of scripts (valid values are 0 through NumScripts-1)


typedef struct {
    int     cBytes;         // Structure length
    WORD    wgBlank;        // Blank glyph
    WORD    wgDefault;      // Glyph used for Unicode values not present in the font
    WORD    wgInvalid;      // Glyph used for invalid character combinations (especially in Thai)
    WORD    wgKashida;      // Shortest continuous kashida glyph in the font, -1 if doesnt exist
    int     iKashidaWidth;  // Widths of shortest continuous kashida glyph in the font
} SCRIPT_FONTPROPERTIES;
]]

ffi.cdef[[
HRESULT  ScriptGetFontProperties(
    HDC                                     hdc,    // In    Optional (see notes on caching)
    SCRIPT_CACHE        *psc,   // InOut Address of Cache handle
    SCRIPT_FONTPROPERTIES   *sfp);  // Out   Receives properties for this font


 HRESULT  ScriptCacheGetHeight(
    HDC                                     hdc,        // In    Optional (see notes on caching)
    SCRIPT_CACHE        *psc,       // InOut Address of Cache handle
    long                    *tmHeight); // Out   Receives font height in pixels
]]

ffi.cdef[[
static const int SSA_PASSWORD        = 0x00000001;  // Input string contains a single character to be duplicated iLength times
static const int SSA_TAB             = 0x00000002;  // Expand tabs
static const int SSA_CLIP            = 0x00000004;  // Clip string at iReqWidth
static const int SSA_FIT             = 0x00000008;  // Justify string to iReqWidth
static const int SSA_DZWG            = 0x00000010;  // Provide representation glyphs for control characters
static const int SSA_FALLBACK        = 0x00000020;  // Use fallback fonts
static const int SSA_BREAK           = 0x00000040;  // Return break flags (character and word stops)
static const int SSA_GLYPHS          = 0x00000080;  // Generate glyphs, positions and attributes
static const int SSA_RTL             = 0x00000100;  // Base embedding level 1
static const int SSA_GCP             = 0x00000200;  // Return missing glyphs and LogCLust with GetCharacterPlacement conventions
static const int SSA_HOTKEY          = 0x00000400;  // Replace '&' with underline on subsequent codepoint
static const int SSA_METAFILE        = 0x00000800;  // Write items with ExtTextOutW Unicode calls, not glyphs
static const int SSA_LINK            = 0x00001000;  // Apply FE font linking/association to non-complex text
static const int SSA_HIDEHOTKEY      = 0x00002000;  // Remove first '&' from displayed string
static const int SSA_HOTKEYONLY      = 0x00002400;  // Display underline only.

static const int SSA_FULLMEASURE     = 0x04000000;  // Internal - calculate full width and out the number of chars can fit in iReqWidth.
static const int SSA_LPKANSIFALLBACK = 0x08000000;  // Internal - enable FallBack for all LPK Ansi calls Except BiDi hDC calls
static const int SSA_PIDX            = 0x10000000;  // Internal
static const int SSA_LAYOUTRTL       = 0x20000000;  // Internal - Used when DC is mirrored
static const int SSA_DONTGLYPH       = 0x40000000;  // Internal - Used only by GDI during metafiling - Use ExtTextOutA for positioning
static const int SSA_NOKASHIDA       = 0x80000000;  // Internal - Used by GCP to justify the non Arabic glyphs only.
]]



ffi.cdef[[
typedef struct tag_SCRIPT_TABDEF {
    int   cTabStops;        // Number of entries in pTabStops array
    int   iScale;           // Scale factor for pTabStops (see below)
    int  *pTabStops;        // Pointer to array of one or more tab stops
    int   iTabOrigin;       // Initial offset for tab stops (logical units)
} SCRIPT_TABDEF;


typedef void* SCRIPT_STRING_ANALYSIS;


 HRESULT  ScriptStringAnalyse(
    HDC                                             hdc,        //In  Device context (required)
    const void                                      *pString,   //In  String in 8 or 16 bit characters
    int                                             cString,    //In  Length in characters (Must be at least 1)
    int                                             cGlyphs,    //In  Required glyph buffer size (default cString*1.5 + 16)
    int                                             iCharset,   //In  Charset if an ANSI string, -1 for a Unicode string
    DWORD                                           dwFlags,    //In  Analysis required
    int                                             iReqWidth,  //In  Required width for fit and/or clip
     SCRIPT_CONTROL               *psControl, //In  Analysis control (optional)
     SCRIPT_STATE                 *psState,   //In  Analysis initial state (optional)
     const int              *piDx,      //In  Requested logical dx array
     SCRIPT_TABDEF                *pTabdef,   //In  Tab positions (optional)
    const BYTE                                      *pbInClass, //In  Legacy GetCharacterPlacement character classifications (deprecated)
     SCRIPT_STRING_ANALYSIS    *pssa);     //Out Analysis of string
]]


ffi.cdef[[
 HRESULT  ScriptStringFree(
     SCRIPT_STRING_ANALYSIS  *pssa);  //InOut Address of pointer to analysis


const SIZE*  ScriptString_pSize(
    SCRIPT_STRING_ANALYSIS   ssa); 


const int*  ScriptString_pcOutChars(
    SCRIPT_STRING_ANALYSIS   ssa); 


const SCRIPT_LOGATTR*  ScriptString_pLogAttr(
    SCRIPT_STRING_ANALYSIS   ssa); 


 HRESULT  ScriptStringGetOrder(
    SCRIPT_STRING_ANALYSIS   ssa,
    UINT                                    *puOrder); 

 HRESULT  ScriptStringCPtoX(
    SCRIPT_STRING_ANALYSIS   ssa,        //In  String analysis
    int                                     icp,        //In  Caret character position
    BOOL                                    fTrailing,  //In  Which edge of icp
     int                     *pX);       //Out Corresponding x offset


 HRESULT  ScriptStringXtoCP(
    SCRIPT_STRING_ANALYSIS   ssa,            // In
    int                                     iX,             // In
     int                     *piCh,          // Out
     int                     *piTrailing);   // Out


 HRESULT  ScriptStringGetLogicalWidths(
    SCRIPT_STRING_ANALYSIS   ssa,
    int                                     *piDx); 


 HRESULT  ScriptStringValidate(
    SCRIPT_STRING_ANALYSIS   ssa); 


 HRESULT  ScriptStringOut(
    SCRIPT_STRING_ANALYSIS   ssa,            //In  Analysis with glyphs
    int                                     iX,             //In
    int                                     iY,             //In
    UINT                                    uOptions,       //In  ExtTextOut options
     const RECT           *prc,           //In  Clipping rectangle (iff ETO_CLIPPED)
    int                                     iMinSel,        //In  Logical selection. Set iMinSel>=iMaxSel for no selection
    int                                     iMaxSel,        //In
    BOOL                                    fDisabled);     //In  If disabled, only the background is highlighted.
]]

ffi.cdef[[
static const int SIC_COMPLEX    = 1;   // Treat complex script letters as complex
static const int SIC_ASCIIDIGIT = 2;   // Treat digits U+0030 through U+0039 as complex
static const int SIC_NEUTRAL    = 4;   // Treat neutrals as complex


 HRESULT  ScriptIsComplex(
    const WCHAR   *pwcInChars,    //In  String to be tested
    int                                 cInChars,       //In  Length in characters
    DWORD                               dwFlags);       //In  Flags (see above)
]]

ffi.cdef[[
typedef struct tag_SCRIPT_DIGITSUBSTITUTE {
    DWORD  NationalDigitLanguage    :16;   // Language for native substitution
    DWORD  TraditionalDigitLanguage :16;   // Language for traditional substitution
    DWORD  DigitSubstitute          :8;    // Substitution type
    DWORD  dwReserved;                     // Reserved
} SCRIPT_DIGITSUBSTITUTE;



HRESULT  ScriptRecordDigitSubstitution(
    LCID                                    Locale,     // In   LOCALE_USER_DEFAULT or desired locale
    SCRIPT_DIGITSUBSTITUTE  *psds);     // Out  Digit substitution settings



static const int SCRIPT_DIGITSUBSTITUTE_CONTEXT     = 0;  // Substitute to match preceeding letters
static const int SCRIPT_DIGITSUBSTITUTE_NONE        = 1;  // No substitution
static const int SCRIPT_DIGITSUBSTITUTE_NATIONAL    = 2;  // Substitute with official national digits
static const int SCRIPT_DIGITSUBSTITUTE_TRADITIONAL = 3;  // Substitute with traditional digits of the locale


HRESULT  ScriptApplyDigitSubstitution(
    const SCRIPT_DIGITSUBSTITUTE *psds,  // In   Digit substitution settings
    SCRIPT_CONTROL              *psc,   // Out  Script control structure
    SCRIPT_STATE                *pss);  // Out  Script state structure
]]

--[[

          OpenType enabled Uniscribe APIs

--]]

local UNISCRIBE_OPENTYPE = 0x0100

ffi.cdef[[
// 4-byte OpenType tag used to identify Script, LangSys or Feature
typedef ULONG OPENTYPE_TAG;

// Undefined script tag.
static const int SCRIPT_TAG_UNKNOWN   = 0x00000000;

// Single OpenType feature
typedef struct opentype_feature_record{

    OPENTYPE_TAG    tagFeature;     // Feature tag
    LONG            lParameter;     // Feature parameter (0 - disabled)

} OPENTYPE_FEATURE_RECORD;

// Set of OpenType properties applied to the range of characters
typedef struct textrange_properties{

    OPENTYPE_FEATURE_RECORD   *potfRecords;
    int                        cotfRecords;

} TEXTRANGE_PROPERTIES;

//
// Character properties
//
// Used by shaping engines to pass shaping information between calls
//
typedef struct script_charprop{
    WORD           fCanGlyphAlone : 1;
    WORD           reserved       : 15; // Reserved
} SCRIPT_CHARPROP;

//
// Glyph properties
//
typedef struct script_glyphprop{

    SCRIPT_VISATTR sva;
    WORD           reserved; // Reserved

} SCRIPT_GLYPHPROP;
]]

ffi.cdef[[
 HRESULT  ScriptShapeOpenType(
                       HDC                     hdc,            // In    Optional (see under caching)
                        SCRIPT_CACHE           *psc,            // InOut Cache handle
                        SCRIPT_ANALYSIS        *psa,            // InOut Result of ScriptItemize (may have fNoGlyphIndex set)

                           OPENTYPE_TAG            tagScript,      // In    Font script tag for shaping
                           OPENTYPE_TAG            tagLangSys,     // In    Font language system tag for shaping
    int                     *rcRangeChars,      // In    Array of number of characters per range
    TEXTRANGE_PROPERTIES   **rpRangeProperties, // In    Array of range properties (for each range)
                           int                     cRanges,           // In    Number of ranges

            const WCHAR             *pwcChars,       // In    Logical unicode run
                           int                     cChars,         // In    Length of unicode run
                           int                     cMaxGlyphs,     // In    Max glyphs to generate

    WORD                    *pwLogClust,     // Out   Logical clusters
    SCRIPT_CHARPROP         *pCharProps,     // Out   Output buffer for character properties
    
    WORD       *pwOutGlyphs,    // Out   Output glyph buffer
    SCRIPT_GLYPHPROP       *pOutGlyphProps, // Out   Visual glyph attributes
                                        int      *pcGlyphs);      // Out   Count of glyphs generated


 HRESULT  ScriptPlaceOpenType(
    HDC                     hdc,            // In    Optional (see under caching)
                        SCRIPT_CACHE           *psc,            // InOut Cache handle
                        SCRIPT_ANALYSIS        *psa,            // InOut Result of ScriptItemize (may have fNoGlyphIndex set)

                           OPENTYPE_TAG            tagScript,      // In    Font script tag for shaping
                           OPENTYPE_TAG            tagLangSys,     // In    Font language system tag for shaping
    int                     *rcRangeChars,      // In    Array of number of characters per range
    TEXTRANGE_PROPERTIES   **rpRangeProperties, // In    Array of range properties (for each range)
    int                     cRanges,           // In    Number of ranges

    const WCHAR             *pwcChars,       // In    Logical unicode run
    WORD                    *pwLogClust,     // In    Logical clusters
    SCRIPT_CHARPROP         *pCharProps,     // In    Output buffer for character properties
    int                     cChars,         // In    Length of unicode run
    
    const WORD              *pwGlyphs,       // In    Glyph buffer from prior ScriptShape call
    const SCRIPT_GLYPHPROP  *pGlyphProps,    // In    Glyph properties
    int                     cGlyphs,        // In    Number of glyphs
    
    int                     *piAdvance,      // Out   Advance widths
    GOFFSET                 *pGoffset,       // Out   x,y offset for combining glyph
    ABC                    *pABC);          // Out   Composite ABC for the whole run (Optional)


 HRESULT  ScriptItemizeOpenType(
    const WCHAR                   *pwcInChars,    // In   Unicode string to be itemized
    int                            cInChars,      // In   Codepoint count to itemize
    int                            cMaxItems,     // In   Max length of itemization array
    const SCRIPT_CONTROL          *psControl,     // In   Analysis control (optional)
    const SCRIPT_STATE            *psState,       // In   Initial bidi algorithm state (optional)
    SCRIPT_ITEM  *pItems,        // Out  Array to receive itemization
    OPENTYPE_TAG *pScriptTags,   // Out  Array of script tags - parallel to items
                     int                           *pcItems);      // Out  Count of items processed (optional)



 HRESULT  ScriptGetFontScriptTags(
               HDC                              hdc,             // In    Optional (see under caching)
                SCRIPT_CACHE                    *psc,             // InOut Cache handle
               SCRIPT_ANALYSIS                 *psa,             // In    Result of ScriptItemize (can be NULL)
                   int                              cMaxTags,        // In    Length of pScriptTags array
    OPENTYPE_TAG  *pScriptTags,     // Out:  list of script tags in the font
                  int                             *pcTags           // Out:  Number of tags returned
);


 HRESULT  ScriptGetFontLanguageTags(
               HDC                    hdc,             // In    Optional (see under caching)
                SCRIPT_CACHE          *psc,             // InOut Cache handle
               SCRIPT_ANALYSIS       *psa,             // In    Result of ScriptItemize  (can be NULL)
                   OPENTYPE_TAG           tagScript,       // In    Font script tag
    
                   int                    cMaxTags,        // In    Length of pLangsys tags array
    OPENTYPE_TAG *pLangsysTags,    // Out:  list of Langsys tags in the font
                  int                   *pcTags           // Out:  Number of tags returned
);


HRESULT  ScriptGetFontFeatureTags(
               HDC                    hdc,             // In    Optional (see under caching)
                SCRIPT_CACHE          *psc,             // InOut Cache handle
               SCRIPT_ANALYSIS       *psa,             // In    Result of ScriptItemize  (can be NULL)
                   OPENTYPE_TAG           tagScript,       // In    Font script tag
                   OPENTYPE_TAG           tagLangSys,      // In    Font language system tag for shaping
    
                   int                    cMaxTags,        // In    Length of pLangsys tags array
    OPENTYPE_TAG *pFeatureTags,   // Out:  list of feature tags in the font
                  int                   *pcTags           // Out:  Number of tags returned
);


 HRESULT  ScriptGetFontAlternateGlyphs(
               HDC                    hdc,             // In    Optional (see under caching)
                SCRIPT_CACHE          *psc,             // InOut Cache handle
               SCRIPT_ANALYSIS       *psa,             // In    Result of ScriptItemize  (can be NULL)
    OPENTYPE_TAG           tagScript,       // In    Font script tag
    OPENTYPE_TAG           tagLangSys,      // In    Font language system tag for shaping
    OPENTYPE_TAG           tagFeature,      // In    Feature tag to test for alternates
    
    WORD                   wGlyphId,        // In    Original glyph
    
    int                    cMaxAlternates,  // In    Length of pAlternateGlyphs tags array
    WORD *pAlternateGlyphs, // Out:  list of feature tags in the font
    int                   *pcAlternates     // Out:  Number of alternates returned
);


 HRESULT  ScriptSubstituteSingleGlyph(
               HDC                    hdc,             // In    Optional (see under caching)
                SCRIPT_CACHE          *psc,             // InOut Cache handle
               SCRIPT_ANALYSIS       *psa,             // In    Result of ScriptItemize  (can be NULL)
                   OPENTYPE_TAG           tagScript,       // In    Font script tag
                   OPENTYPE_TAG           tagLangSys,      // In    Font language system tag for shaping
                   OPENTYPE_TAG           tagFeature,      // In    Feature tag to test for alternates
                   LONG                   lParameter,      // In    Feature parameter

                   WORD                   wGlyphId,         // In    Original glyph id
                  WORD                  *pwOutGlyphId      // Out   Substituted glyph id
);


 HRESULT  ScriptPositionSingleGlyph(
               HDC                    hdc,             // In    Optional (see under caching)
                SCRIPT_CACHE          *psc,             // InOut Cache handle
               SCRIPT_ANALYSIS       *psa,             // In    Result of ScriptItemize  (can be NULL)
                   OPENTYPE_TAG           tagScript,       // In    Font script tag
                   OPENTYPE_TAG           tagLangSys,      // In    Font language system tag for shaping
                   OPENTYPE_TAG           tagFeature,      // In    Feature tag to test for alternates
                   LONG                   lParameter,      // In    Feature parameter

                   WORD                   wGlyphId,         // In    Glyph id to be moved
                   int                    iAdvance,         // In    Original glyph advance width
                   GOFFSET                GOffset,          // In    Original glyph offset
                  int                   *piOutAdvance,     // Out   Adjusted advance width
                  GOFFSET               *pOutGoffset       // Out   Adjusted offset
);
]]



